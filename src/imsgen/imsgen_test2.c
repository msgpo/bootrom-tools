/*
 * Copyright (c) 2015 Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 *
 * @brief: This file contains the code for "imsgen_test2"
 *
 * This verifies a message signed with RSA, ECC primary and ECC secondary
 * signatures. The EP_UID, and signatures are provided in separate files
 * generated by "imsgen_test1".
 *
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <getopt.h>
#include <libgen.h>
#include <openssl/evp.h>    /* for EVP_MAX_MD_SIZE */
#include "util.h"
#include "parse_support.h"
#include "mcl_arch.h"
#include "mcl_oct.h"
#include "mcl_ecdh.h"
#include "mcl_rand.h"
#include "mcl_rsa.h"
#include "crypto.h"
#include "ims_common.h"
#include "ims_test_core.h"
#include "ims_test2.h"


/* Program return values */
#define PROGRAM_SUCCESS     0
#define PROGRAM_WARNINGS    1
#define PROGRAM_ERROR       2

#define KEYPTYPE_EPSK       0
#define KEYPTYPE_ESSK       1
#define KEYPTYPE_ERRK       2

parse_entry key_types[] = {
        {"epsk",  KEYTYPE_EPSK},
        {"EPSK",  KEYTYPE_EPSK},
        {"essk",  KEYTYPE_ESSK},
        {"ESSK",  KEYTYPE_ESSK},
        {"errk",  KEYTYPE_ERRK},
        {"ERRK",  KEYTYPE_ERRK},
    {NULL, 0}
};


/* Argument handling function prototype */
bool handle_key_type(const int option, const char * optarg,
                     struct optionx * optx);


/* Parsing args */
char *  message_filename;
char *  ep_uid_filename;
char *  database_name;
char *  sig_filename;
int     key_type;
int     sample_compatibility_mode = 0;

char *  message_filename_names[] = { "message", "in", NULL };
char *  ep_uid_filename_names[] = { "ep-uid", "ep_uid", NULL };
char *  database_name_names[] = { "db", "database", NULL };
char *  sig_filename_names[] = { "signature", "sig", NULL };
char *  key_type_names[] = { "key-type", "key", NULL };
char *  sample_compatibility_mode_names[] = { "compatibility", NULL };


/* Parsing table */
static struct optionx parse_table[] = {
        { 'm', message_filename_names, NULL,
          &message_filename, 0, REQUIRED, &store_str, false,
          "The name of the message file to verify" },
        { 'e', ep_uid_filename_names, NULL,
          &ep_uid_filename, 0, REQUIRED, &store_str, false,
          "The name of the file containing the EP_UID" },
        { 'd', database_name_names, NULL,
          &database_name, 0, REQUIRED, &store_str, false,
          "The name of the certificate database" },
        { 's', sig_filename_names, NULL,
          &sig_filename, 0, REQUIRED, &store_str, false,
          "The name of the file containing the RSA signature" },
        { 'k', key_type_names, NULL,
          &key_type, 0, REQUIRED, &handle_key_type, false,
          "The name of the file containing the primary ECC signature" },
        { 0, NULL, NULL, NULL, 0, 0, NULL, 0, NULL }
};

static char all_args[] = "m:e:d:s:k:c";


/**
 * @brief Callback to validate and store the signing key type.
 *
 * @param option The option character (may be used to disambiguate a
 *        common function)
 * @param optarg The string from the argument parser
 * @param optx A pointer to the option descriptor
 *
 * @returns Returns true on success, false on failure
 */
bool handle_key_type(const int option, const char * optarg,
                     struct optionx * optx) {
    *(uint32_t*)optx->var_ptr = kw_to_token(optarg, key_types);
    return (*(uint32_t*)optx->var_ptr != TOKEN_NOT_FOUND);
}


/**
 * @brief Post-process and validate the command line args
 *
 * @param argc The number of elements in argv or parsed_argv (std. unix argc)
 *
 * @returns 0 on success, 1 if there were warnings, 2 on failure
 */
static int postprocess_args(int argc) {
    int status = PROGRAM_SUCCESS;

    if (optind < argc) {
        fprintf(stderr, "ERROR: dangling arguments\n");
        status = PROGRAM_ERROR;
    }

    return status;
}

/**
 * @brief Entry point for the imsgen application
 *
 * @param argc The number of elements in argv or parsed_argv (std. unix argc)
 * @param argv The unix argument vector - an array of pointers to strings.
 *
 * @returns 0 on success, 1 if there were warnings, 2 on failure
 */
int main(int argc, char * argv[]) {
    int status = 0;
    bool success = true;
    struct argparse * parse_tbl = NULL;
    int program_status = PROGRAM_SUCCESS;
    uint32_t count;

    /* Parse the command line arguments */
    parse_tbl = new_argparse(parse_table, argv[0], NULL, NULL, "<file>...", NULL);
    if (parse_tbl) {
        if (!parse_args(argc, argv, all_args, parse_tbl)) {
            program_status = parser_help? PROGRAM_SUCCESS : PROGRAM_ERROR;
        }
        parse_tbl = free_argparse(parse_tbl);

        /* Perform any argument validation/post-processing */
        if (program_status == PROGRAM_SUCCESS) {
            program_status = postprocess_args(argc);
        }
    } else {
        program_status = PROGRAM_ERROR;
    }


    if (program_status == PROGRAM_SUCCESS) {
        /* Open the DB, IMS file, etc.  */
        if (ims_init("/dev/random", NULL, database_name) != 0) {
            fprintf(stderr, "ERROR: IMS initialization failed\n");
            program_status = PROGRAM_ERROR;
        } else {
            /* Test N IMS values */
            status = test_ims_verify(message_filename,
                                     ep_uid_filename,
                                     database_name,
                                     sig_filename,
                                     key_type,
                                     sample_compatibility_mode);
            if (status != 0) {
                fprintf(stderr, "ERROR: message failed to verify (err %d)\n", status);
                program_status = PROGRAM_ERROR;
            }

            /* Close the DB, IMS file */
            ims_deinit();
        }
    }

    return program_status;
}
